#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>

// 1790 _ 수 이어 쓰기 2

// 문제
// 1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.
// 
// 1234567891011121314151617181920212223...
// 
// 이렇게 만들어진 새로운 수에서, 앞에서 k번째 자리 숫자가 어떤 숫자인지 구하는 프로그램을 작성하시오.
// 
// 입력
// 첫째 줄에 N(1 ≤ N ≤ 100, 000, 000)과, k(1 ≤ k ≤ 1, 000, 000, 000)가 주어진다.
// N과 k 사이에는 공백이 하나 이상 있다.
// 
// 출력
// 첫째 줄에 앞에서 k번째 자리 숫자를 출력한다.
// 수의 길이가 k보다 작아서 k번째 자리 숫자가 없는 경우는 - 1을 출력한다.

int main() {
    long long int N;
    long long int K;
    scanf("%lld %lld", &K, &N);
    int memoryi;
    long long int sum = 0; // 문자열의 길이 저장하는 변수

    for (int i = 0; i < 1000; i++) { // 충분히 반복하면서
        sum = (9 * pow(10, i)) * (i + 1);
        N = N - sum; // N이 230이라 가정했을때 1~9까지 문자열의 개수는 9
        //10~99까지의 문자열의 개수는 180(90*2), 100~999 까지 문자열의 개수는 2700 (900*3)

        //230  -9  -180  -2700

        if (N < 0) { // 그 과정에서 N이 음수가 되었다면
            N = N + sum; // 전 단계로 되돌리고
            memoryi = i + 1; // 10이 곱해진 숫자를 기억한다.
            // N은 230-189인 41이 되며 i는 2가 된다
            break;
        }
    }

    // start 변수는 N번째 위치에 있는 원래 숫자-1 을 나타낸다.
    long long int start = pow(10, memoryi - 1) + N / memoryi - 1;
    // 100 + (41/3) - 1 인 112가 된다.
    int order = N % memoryi; // 41이였던 N이 3자리 차례인 숫자들중에서 어느 곳에 위치하고있는지 나머지를 구한다
    if (order == 0) { // 나머지가 0이라면 
        if (start > K) {
            printf("-1");
            return 0;
        }
        printf("%d", start % 10);
    }
    else { // 나머지가 0이 아니라면
        start++; // 현재 start가 112이고 나머지가 2이다. 112/113114115 이런식으로 진행되며
        // 나머지에 따라 숫자가 결정된다. start의 맨 뒷자리인 2를 기준으로 나머지만큼 오른쪽으로 진행된다.
        // 나머지가 0이라면 2를 출력 나머지가 2라면 1을 출력한다.
        if (start > K) { // 단 start인 112가 처음 입력했던 숫자인 K보다 클경우 -1로 예외처리한다.
            printf("-1");
            return 0;
        }
        for (int i = order; i < memoryi; i++) {
            start = start / 10;
        }
        printf("%d", start % 10);
    }
}